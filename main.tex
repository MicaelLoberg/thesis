%Notes to myself:
%ABS:
%   http://abs-models.org/documentation/manual/#sec:algebraic-data-types
%   http://delivery.acm.org/10.1145/3130000/3122848/a76-boer.pdf?ip=130.238.252.224&id=3122848&acc=ACTIVE%20SERVICE&key=74F7687761D7AE37%2EDA50417A8F734F4C%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=1012165178&CFTOKEN=22086748&__acm__=1512138297_7db1453bc51abbd04fa38d02cff9f460 Page >= 11
%
%
%
%

\documentclass[10pt]{report}

\usepackage[utf8]{inputenc}
\usepackage{float}
%\setlength{\parindent}{0pt} % no auto indent

% CLICKABLE LINKS IN TOC,CITE,REF, ETC.
%\usepackage[hidelinks]{hyperref}

% TABLES
\usepackage{tabularx,booktabs,multirow,bigdelim} % for big parenthesis on side of table
\usepackage[table]{xcolor}

% GRAPHICS
\usepackage{graphicx}
\graphicspath{{images/}}

% BIBLIOGRAPHY
\usepackage[bibstyle=nature, citestyle=numeric-comp]{biblatex}
%\usepackage{natbib}
%\bibliographystyle{plain} % plain
\bibliography{references}

% APPENDICES
\usepackage[toc,page]{appendix}

% CHAPTER STYLE
\usepackage{titlesec}
\titleformat{\chapter}{\normalfont\huge}{\thechapter.}{20pt}{\huge\bf}

% TIKZ
\usepackage{tikz}
\usepackage{pgf}
\usetikzlibrary{trees}
\usetikzlibrary{shadows,positioning}

% COLORS
\usepackage{color}
\definecolor{eclipseBlue}{RGB}{42,0.0,255}
\definecolor{eclipseGreen}{RGB}{63,127,95}
\definecolor{eclipsePurple}{RGB}{127,0,85}
\definecolor{codeListingBackground}{gray}{0.95}

% CODE LISTINGS
\usepackage{listings}
\usepackage{caption,subcaption}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
%% Define Language
\lstdefinelanguage{Encore}
{
  morekeywords={
  active,
  case,catch,chain,class,data,
  def,do,
  eos,else,end,exception,
  finally,for,fun,
  get,getNext,
  if,import,in,
  let,linear,
  match,module,new,
  print,println,
  qualified,
  return,require,
  shared,stream,
  then,this,throw,trait,try,typedef,
  unless,unsafe,
  val,var,
  when,where,while,with,
  yield
  },
  sensitive=true, % keywords are not case-sensitive
  morecomment=[l]{--}, % l is for line comment
  morestring=[b]" % defines that strings are enclosed in double quotes
}

\lstdefinelanguage{Scala}
{
  morekeywords={
  match, case, object, class, extends,
  sealed, trait, =>
  },
  sensitive=true, % keywords are not case-sensitive
  morecomment=[l]{--}, % l is for line comment
  morestring=[b]" % defines that strings are enclosed in double quotes
}

%\lstset{numbers=left,xleftmargin=2em,frame=single,framexleftmargin=1.5em}

\lstset{
%  language={Encore},
  basicstyle=\footnotesize\ttfamily, % Global Code Style
  backgroundcolor=,%\color{codeListingBackground},
  captionpos=b, % Position of the Caption (t for top, b for bottom)
  extendedchars=true, % Allows 256 instead of 128 ASCII characters
  tabsize=1, % number of spaces indented when discovering a tab
  columns=fixed, % make all characters equal width
  keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
  showstringspaces=false, % lets spaces in strings appear as real spaces
  breaklines=true, % wrap lines if they don't fit
  frame=none, % e.g. none/tbrl/single/lines. tbrl = draw a frame at the top, right, left and bottom of the listing.
  xleftmargin=2ex,
  framexleftmargin=0pt,
  framexrightmargin=0pt,
  framextopmargin=0pt,
  framexbottommargin=0pt,
  frameround=ffff, % make the frame round at all four corners
  framesep=0pt, % quarter circle size of the round corners
  numbers=left, %left, % show line numbers at the left
  numberstyle=\color{eclipseBlue}\tiny\ttfamily, % style of the line numbers
  numbersep=3pt, % distance between numbers and code
  commentstyle=\color{eclipseGreen}, % style of comments
  keywordstyle=\bf, % style of keywords \color{eclipsePurple}
  stringstyle=, % style of strings \color{eclipseBlue}
  showlines=true,
}

\lstdefinestyle{encattachment} {
  language=Encore,
  frame=none,
  captionpos=t,
  numbers=none,
  frame=tbrl,
  framexleftmargin=2pt,
  framexrightmargin=2pt,
  framextopmargin=2pt,
  framexbottommargin=2pt,
}


% CUSTOM COMMANDS
\def\code#1{\texttt{#1}} % Code-esque text
\def\todo#1{\textcolor{blue}{\{TODO: #1\}}}
\def\name#1{\textsc{#1}} % Proper nouns, names, logos, names of programming languages

\title{
    {Algebraic data types in Encore:}\\
    {reconciling objection-oriented and functional programming}\\
    {Uppsala University}
}

\author{Micael Loberg}
\date{\today}

\begin{document}
\pagenumbering{roman}

\maketitle

\newpage\newpage
%\vspace*{\fill}
{\centering \textit{This page intentionally left blank}\par}
\vspace{\fill}


\chapter*{Abstract}
TODO

\newpage\newpage
%\vspace*{\fill}
{\centering \textit{This page intentionally left blank}\par}
\vspace{\fill}


\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\chapter{Introduction}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagenumbering{arabic}
\setcounter{page}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\section{Background}
\label{ch:background}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{encore}
Encore is an object-oriented programming language developed at Uppsala University blah blah
TODO
\subsection{Algebraic Data Types}
Algebraic data types (ADTs) are used to define composite data.  Data structures can in type theory be described in terms of products, sums and recursive types. This leads to an algebra for describing data structures (hence Algebraic Data Types). Such data types are common in functional languages, such as ML or Haskell.
\\
\\
Robert Harper describes \textbf{Products} of types in the book \textit{'Practical Foundations for Programming Languages'} as the following:
\\
\\
\textit{"The binary \textbf{product} of two types consists of ordered pairs of values, one from each type in the order specified. The associated eliminatory forms are projections, which select the first and second component of a pair. The nullary product, or unit, type consists solely of the unique “null tuple” of no values, and has no associated eliminatory form."}
\\
\\
\textbf{Sums} of products can be seen as the choice of two or more variants of a data structure, both producs and sums can be seen in the following example of a polymorphic binary tree.  Here Tree is the name of the type and Nil and Branch are constructors that are used to create new instances of type Tree and t is a type variable.  The type Tree is also recursive as it is defined in terms of itself.
\\
\\
\begin{lstlisting}[language=Haskell,caption={Binary tree definition in Haskell},label={lst:e4c_syntax}]
data Tree t = Nil
            | Branch t (Tree t) (Tree t)
\end{lstlisting}
\subsubsection{ADTs In Functional Languages}% (this section has more become something like 'ADTs vs Classes' :/ )
In most functional languages there are no objects, so the primary method of defining composite data is with Algebraic Data Types.
\\
\\
Though ADTs is in no way equivalent with classes. Some of the major differences is mutability. Instance variables in a class is generally mutable while values in an ADT is not. Another distinction is that Algebraic Data Types allow for both sums and products while classes only allows for products.
\\
\\
ADTs also expose their insides to the world in a way that classes do not. This allows the programmer to perform pattern matching on the structure of an Algebraic Data Type. Pattern matching on the structure of types is also a feature that is mostly found in Functional languages and is critical to work with ADTs an effective manner.
\subsubsection{ADTs In Imperative/OO Languages}
While Algebraic Data Types is mostly found in functional languages there are examples of imperative languages that features them. Perhaps most notably in Scala.
\\
\\
Algebraic Data Types in Scala comes in the form of Variant types. A binary tree in Scala could have the following definition:
\\
\\

\begin{lstlisting}[language=Scala,caption={ADT definition in Scala},label={lst:e4c_syntax}]
sealed trait Tree[+T]
case object Nil extends Tree[Nothing]
case class Branch[T](value:T, left:Tree[T], right:Tree[T]) extends Tree[T]
\end{lstlisting}
Noteworthy here is that the ADT is defined in terms of a Trait and classes extending the trait.  A sealed trait is a special kind of trait that can only be extended in the same file as it is defined.  A case class is mostly a normal class with a few differences such as its being immutable.  Case classes can also be used in pattern matching:
\begin{lstlisting}[language=Scala,caption={Pattern matching on an ADT in Scala}]
tree match {
    case Branch(value, left, right) => Foo()
    case Nil()  => Bar()
}
\end{lstlisting}
One can easily see the similarities of this implementation and the one in listing $1.1$. Here Tree is the new type, Nil and Branch could be seen as constructors for the type Tree.
\\
\\
By using the scheme of traits and classes to create something that looks and behaves a lot like an ADT Scala have created objects and are both sum and product types, and the fact that case classes can be used in destructured pattern matching allows for allows for programming patterns normally found only in functional languages.
\chapter{Encoding ADTs in Encore}
\subsection{Encoding scheme}
\par{\noindent In Encore it is possible to emulate the behaviour of ADTs using a scheme of traits and classes.}\cite{gustavL}%TODO: add reference to Gustav Lundins paper
\par{\noindent An implementation of a linked list in Encore could consist of the two classes \texttt{Node} and \texttt{Last}, both of which implements a trait \texttt{LinkedList}\\}
\par{\noindent Classes can implement destructor methods that exposes the internal structure of an object which can then be used in pattern matching. If the trait \texttt{LinkedList} requires the classes who implements the trait to also implement destructor methods, an object of type \texttt{LinkedList} can be used in pattern matching}

\begin{lstlisting}[language=encore,caption={trait LinkedList that requires classes to implement destructor methods}]
trait LinkedList[t]
  require def Node() : Maybe[(t, LinkedList)]
  require def Last() : Maybe[(t)]
end
\end{lstlisting}
\par{\noindent An object of type \texttt{Node} will implement both of the extractor methods \texttt{Node()} and \texttt{Last}. The method \texttt{Node()} will return a \texttt{Just} with a tuple consisting of the internal objects to be exposed, in this case \texttt{value} and \texttt{next} while the method \texttt{Last()} will return \texttt{Nothing}}

\par{\noindent Similarly an object of type \texttt{Last} will also implement both extractor methods \texttt{Node()} and \texttt{Last()}. Though here the method \texttt{Node()} will return \texttt{Nothing} while \texttt{Last()} returns \texttt{Just(value).}}


\begin{lstlisting}[language=encore,caption={Implementation of Node and Last classes}]
read class Node[t] : List[t](value, next)
  val value : t
  val next : List[t]

  def init(value : t, next : List[t]) : unit
    this.value = value
    this.next = next
  end

  def Last() : Maybe[t]
    Nothing
  end

  def Node() : Maybe[(t, List[t])]
    Just((this.value, this.next))
  end
end

read class Last[t] : List[t](value)
  val value : t

  def init(value : t) : unit
    this.value = value
  end

  def Last() : Maybe[t]
    Just(this.value)
  end

  def Node() : Maybe[(t, List[t])]
    Nothing
  end
end
\end{lstlisting}

\par{\noindent To make the classes \texttt{Node} and \texttt{Last} look more like branches of an ADT and hide the fact that they are classes, we also add constructor functions to create the objects for us.}

\begin{lstlisting}[language=encore,caption={Constructor functions for Node and Last}]
fun Node[t](value : t, next : List[t]) : List[t]
  new Node[t](value, next)
end

fun Last[t](value : t) : List[t]
  new Last[t](value)
end
\end{lstlisting}

A LinkedList containing the values $[1, 2, 3]$ can now be created like this
\begin{lstlisting}[language=encore,caption={Creation of list containing three elements}]
var list = Node(1, Node(2, Last(3)))
\end{lstlisting}

The variable \texttt{list} can now be used in pattern matching

\begin{lstlisting}[language=encore,caption={Function that uses pattern matching to calculate the length of a list}]
fun listLength[t](list : List[t]) : int
  match list with
    case Node(value, next) => 1 + listLength(next)
    case Last(value) => 1
  end
end
\end{lstlisting}

\par{\noindent Now we have something that looks and behaves a lot like an ADT in for example Haskell. We have functions that creates the objects for us and hides the fact that we're creating an object from a class and we can perform pattern matching on the structure of of the object.}

\subsection{Problems with encoding}
TODO
\chapter{Design}
TODO
\subsection{Syntax}
The syntax for ADTs have gone through a number of iterations before we settled on the final one described below.
It is inspired by the syntax Scale use for its Variant types, but modified to fit in with the rest of the Encore language.

An adt is defined by using the keyword \'data\', followed by an identifier starting with a capital letter.
\begin{lstlisting}[language=Encore]
data Foo
\end{lstlisting}
A branch (or constructor?) of an ADT is defined as following:
\begin{lstlisting}[language=Encore]
case Bar(valueA : t1, valueB : t2) : Foo
\end{lstlisting}
where \texttt{Bar} is the name of the branch, \texttt{valueA} and \texttt{valueB} are the fields of type t1 and t2, \texttt{:Foo} lets the compiler know that \texttt{Bar} is a branch of \texttt{Foo}.
A branch does not have to be defined on the line following the ADT, but anywhere as long as it is in the same file.
Both ADTs and its branches can define methods. Methods are defined on a new indented line under the ADT/branch definition.
A ADT or branch that have methods defined needs to be closed with the \texttt{end} keyword.
\begin{lstlisting}[language=encore,caption={ADT definition with a method}]
data Foo
  def Bar() : unit
    --methodbody
  end
end
\end{lstlisting}
ADTs can also take optional type parameters. Type parameters are defined with a comma separated list within brackets
\begin{lstlisting}[language=encore,caption={Generic linked list implemented with an ADT}]
data List[t]
case Node[t](value : t, next : List[t]) : List[t]
case Nil[t]() : List[t]
\end{lstlisting}
To create an instance of a branch you call the constructor functions that is generated for each of the branches.
A instance of a \texttt{Node} can be created like this:
\begin{lstlisting}[language=encore,caption={Declaration of a list containing one element}]
let
  list = Node(1, Nil())
in
  --body
end
\end{lstlisting}
ADTs can be used in pattern matching expressions
\begin{lstlisting}[language=encore,caption={Pattern matching on a linked list}]
match list with
  case Node(value, next) => Foo()
  case Nil() => Bar()
end
\end{lstlisting}
\subsection{Behaviour}
As ADTs and their branches gets desugared to read only traits and classes they can do everything traits and classes are capable of.
Methods that are declared inside of the ADT declaration ends up in the trait as required methods, and methods declared in the branch end up in the class. It's however worth to note that in the current state of Encore, when you call a constructor function for a branch you will get an object with the type of the trait back. So right now it's not possible to ever call a method on an ADT branch. This can quite easily be solved by adding a few more features to Encore, this I will discuss in chapter 6.
\\\\As mentioned above, the classes and traits generated are read only, this means that the values held by an ADT branch are immutable.  The main motivation for them being immutable is that it is what I believe most users will expect from an ADT as its a language feature mostly found in functional languages. It also makes them safe to pass around between different actors as no actor is able to modify it.\\\\
\chapter{Implementation}

\subsection{Implementation via desugaring}
\par{\noindent The Encore compiler is written in Haskell and generates C code as output which is then piped into Clang to generate executable code. The Encore compiler has a desugaring phase that can be used to turn the ADT nodes in the Abstract Syntax Tree (AST) into class and trait nodes. Methods that are used as constructors for the different branches will also be created.\\\\}
\par{\noindent The following linked list implemented with an ADT}

\begin{lstlisting}[language=encore,caption={Linked list before it has been desugared}]
data List[t]
case Node[t](value : t, next : List[t]) : List[t]
case Last[t](value : t) : List[t]
\end{lstlisting}

\par{\noindent will after the desugaring phase be transformed to the following trait, classes and methods.}

\begin{lstlisting}[language=encore,caption={Desugared linked list}]
read trait List[t]
  require def Last() : Maybe[t]
  require def Node() : Maybe[(t, List[t])]
end

read class Node[t] : List[t](value, next)
  val value : t
  val next : List[t]

  def init(value : t, next : List[t]) : unit
    this.value = value
    this.next = next
  end

  def Last() : Maybe[t]
    Nothing
  end

  def Node() : Maybe[(t, List[t])]
    Just((this.value, this.next))
  end
end

read class Last[t] : List[t](value)
  val value : t

  def init(value : t) : unit
    this.value = value
  end

  def Last() : Maybe[t]
    Just(this.value)
  end

  def Node() : Maybe[(t, List[t])]
    Nothing
  end
end

fun Node[t](value : t, next : List[t]) : List[t]
  new Node[t](value, next)
end

fun Last[t](value : t) : List[t]
  new Last[t](value)
end

\end{lstlisting}

\par{\noindent The trait generated on lines $X-YY$ requires that the classes implements extractor methods, one for each branch of the ADT\@. The extractor methods are used in pattern matching and their purpose will be discussed in the next chapter. In this case the extractor methods are \texttt{Node()} and \texttt{Last()}.\\}

\par{\noindent Every branch in the ADT will be transformed into a class containing the fields contained in the branch, a constructor method and extractor methods for all the branches of the ADT.\\}

\par{\noindent A creator function for each branch will also be created. These are used as a syntactic sugar to create instances of the ADTs branches and hide the fact that they are implemented as classes.}

\subsection{Pattern matching optimization}
TODO

\chapter{Evaluation and discussion}
TODO
\section{Expressive power}
TODO
\subsection{Some cool example}
TODO
\subsection{Performance}
TODO
\subsubsection{Benchmark}
TODO
\chapter{Conclusion and Future work}
TODO

%#Källor:
%http://www.cs.cmu.edu/~rwh/pfpl.html
\printbibliography

\chapter{References}


\begin{thebibliography}{9}
\bibitem{gustavL} 
Gustav Lundin
\textit{Pattern Matching in Encore}. 
http://www.diva-portal.org/smash/get/diva2:930151/FULLTEXT01.pdf
 
\end{thebibliography}


\begin{appendices}
\end{appendices}
\end{document}
